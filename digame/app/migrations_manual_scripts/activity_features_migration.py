"""
Manually defined Alembic migration for the ActivityEnrichedFeature model.
This is provided because autogeneration is currently failing.
"""

from alembic import op
import sqlalchemy as sa

# Placeholder revision identifiers. In a real scenario, these would be generated by Alembic.
revision = 'manual_add_activity_features_table'
# Replace with the actual revision ID of the migration that created 'digital_activities' table
# or the latest migration if 'digital_activities' is much older.
# For this example, let's assume a previous migration for 'digital_activities' exists.
down_revision = 'previous_migration_that_created_digital_activities' 
branch_labels = None
depends_on = None


def upgrade():
    """
    Creates the 'activity_enriched_features' table in the database.
    """
    op.create_table(
        'activity_enriched_features',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        
        # Foreign Key to digital_activities.id, unique to ensure one-to-one
        sa.Column('activity_id', sa.Integer(), nullable=False, unique=True), 
        
        sa.Column('app_category', sa.String(), nullable=True),
        sa.Column('project_context', sa.String(), nullable=True),
        sa.Column('website_category', sa.String(), nullable=True),
        sa.Column('is_context_switch', sa.Boolean(), server_default=sa.false(), nullable=True), # Default to False
        
        # Constraints
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['activity_id'], ['digital_activities.id'], name='fk_activity_features_activity_id_activities')
    )
    
    # Create indexes explicitly
    op.create_index(op.f('ix_activity_enriched_features_id'), 'activity_enriched_features', ['id'], unique=False)
    op.create_index(op.f('ix_activity_enriched_features_activity_id'), 'activity_enriched_features', ['activity_id'], unique=True) # unique=True due to one-to-one

def downgrade():
    """
    Removes the 'activity_enriched_features' table from the database.
    """
    op.drop_index(op.f('ix_activity_enriched_features_activity_id'), table_name='activity_enriched_features')
    op.drop_index(op.f('ix_activity_enriched_features_id'), table_name='activity_enriched_features')
    
    op.drop_table('activity_enriched_features')

# Note on `server_default=sa.false()` for Boolean:
# Using sa.false() (or sa.true()) is the SQLAlchemy way to set a server default for boolean
# that translates correctly across different database backends (e.g., 0/1 for SQLite/MySQL, 'false'/'true' for PostgreSQL).
# If `nullable=False` and `default=False` were used on the model, autogenerate might produce
# `server_default=sa.text('0')` or similar, which is also fine. `sa.false()` is cleaner.
# If `nullable=True` and `default=False` is on the model, then `server_default` might not be set
# by autogenerate, relying on the application to provide the default.
# For this manual DDL, `server_default=sa.false()` with `nullable=True` means if the app doesn't
# provide a value, the DB will default it to false, but it can still be set to NULL.
# If it should NOT be nullable and default to false: `nullable=False, server_default=sa.false()`.
# The current model `is_context_switch = Column(Boolean, nullable=True, default=False)` implies nullable with an app-side default.
# For a DB-side default on a nullable Boolean, `server_default=sa.false(), nullable=True` is appropriate.
# This ensures the DB has a default if the app omits the field, while still allowing NULL if explicitly set.
